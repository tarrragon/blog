---
title: "計劃性延後與逃避行為判別方法論"
date: 2025-09-20
draft: false
description: "明確定義什麼是可接受的計劃性延後，什麼是必須避免的逃避行為"
tags: ["方法論", "工作準則", "開發原則","AI協作心得"]
---

## 背景

在與 LLM AI 協作時，我們發現 AI 面對複雜問題會傾向延後或簡化。這促使我們建立明確的判別準則：什麼是可接受的延後，什麼是逃避。

<!--more-->

這套準則不只適用於 AI，也是我們所有開發決策的指導原則。

## 核心立場

### 我們接受的：計劃性延後

計劃性延後是正當的開發策略。我們接受並鼓勵以下形式的延後：

#### 版本規劃的延後

- v0.1 做基礎功能，v0.2 加進階功能 → **正確**
- 明確標註「此功能於 v0.3 實作」→ **正確**
- 每個版本有完整可用的交付物 → **必要**

#### TDD 最小實現

- 先通過測試，再優化效能 → **正確**
- 實作最小功能，重構階段再改善 → **正確**
- 為擴展預留介面，但不過度設計 → **正確**

#### 風險管理的優先級

- 核心流程優先，邊緣案例延後 → **合理**
- 安全問題優先，美觀問題延後 → **必要**
- 已知範圍的問題，計劃性處理 → **專業**

### 我們拒絕的：逃避行為

以下行為是逃避，必須立即糾正：

#### 模糊的拖延

- 「太複雜，之後再說」→ **錯誤**
- 「暫時跳過」但無具體計劃 → **錯誤**
- 「先將就用」沒有改善時程 → **錯誤**

#### 核心責任的迴避

- 發現架構問題但繞過 → **不可接受**
- 省略錯誤處理 → **不可接受**
- 降低測試標準來通過 → **不可接受**

#### 債務的累積

- TODO 沒有追蹤和時程 → **失職**
- 臨時方案變永久 → **技術腐敗**
- 問題擴散不處理 → **專案危機**

## 處理原則

### 面對複雜問題

複雜不是逃避的理由。我們的處理方式：

1. **分解**：任何複雜問題都能分解為可管理的部分
2. **排序**：依影響和依賴關係決定處理順序
3. **執行**：逐步解決，每步都有可驗證的成果

### 意外狀況的決策

遇到預期外的技術挑戰時：

#### 立即解決的情況

- 阻塞其他開發 → **立即處理**
- 影響資料完整性 → **立即處理**
- 安全漏洞 → **立即處理**

#### 可以延後的情況

- 效能優化（功能正常）→ **可計劃延後**
- UI 美化（體驗可用）→ **可計劃延後**
- 邊緣案例（主流程正常）→ **可計劃延後**

#### 需要重新評估的情況

- 暴露設計缺陷 → **停下來重新設計**
- 依賴關係錯誤 → **調整架構**
- 需求理解偏差 → **重新確認需求**

## 執行標準

### 延後必須有記錄

每個延後決定都要：

- 記錄在工作日誌
- 標註預計處理時間
- 說明延後的理由

### 定期檢視累積

- Sprint 結束檢查延後項目
- 版本發布前清理技術債務
- 超過兩個版本的延後必須處理

### 品質底線不妥協

無論如何都不能延後的：

- **安全性**：任何安全問題
- **資料完整性**：可能造成資料遺失或錯誤
- **核心體驗**：用戶主要使用路徑

## 判別範例

### ✅ 正確的延後

```javascript
// TODO: v0.2 版本加入批次處理
// 目前 v0.1 實作單筆處理
function processItem(item) {
  return processSingle(item); // 完整功能，可延後優化
}
```

理由：功能完整、有明確版本規劃、不影響使用。

### ❌ 錯誤的逃避

```javascript
// TODO: 錯誤處理太麻煩，先不做
function riskyOperation() {
  return doOperation(); // 缺少錯誤處理，不可接受
}
```

理由：核心責任缺失、沒有時程、影響穩定性。

### ✅ 正確的最小實現

```javascript
class DataProcessor {
  process(data) {
    // v0.1: 同步處理
    return this.syncProcess(data);
  }

  // 預留介面給 v0.2 非同步處理
  async processAsync(data) {
    throw new Error('v0.2 功能');
  }
}
```

理由：當前版本完整可用、為未來預留空間、有清楚邊界。

### ❌ 錯誤的妥協

```javascript
// 測試太嚴格，先降低標準
test.skip('應該要處理邊界情況', () => {
  // 跳過困難的測試
});
```

理由：降低品質標準、逃避問題、累積風險。

## 文化與態度

### 我們的信念

- **沒有解決不了的問題**，只有還沒找到的方法
- **延後是策略**，逃避是失職
- **技術債務必須管理**，不是忽視

### 我們的承諾

- 誠實面對技術挑戰
- 為決定負責並追蹤
- 維持專案的長期健康

### 我們的標準

- 每個延後都有明確計劃
- 每個問題都有解決方案
- 每個決定都能說明理由

## 執行保障：永不妥協 Hook 系統

### 我們的解決方案

為了確保這些原則被確實執行，我們建立了永不妥協的 Hook 系統。

#### 即時檢測

系統會在關鍵時刻檢查是否有逃避行為：

- 提交程式碼時
- 編輯文件時
- 開始新任務時

#### 修復模式

當發現逃避行為時：

- 進入修復模式
- 提供明確的修正指引
- 完成修正後才能繼續

#### 上下文理解

系統能分辨：

- 技術文檔中的範例程式碼
- 計劃性的版本規劃
- 真正的逃避行為

### Hook 系統的作用

Hook 系統確保：

- 原則被一致執行
- 問題被及時發現
- 品質不因壓力妥協

## 結論

這套方法論是我們的工作準則。計劃性延後是正當策略，逃避性拖延必須糾正。

我們用明確的原則定義什麼可以接受，什麼必須拒絕。Hook 系統確保這些原則被執行。

這是要求，不是建議。這是標準，不是理想。

任何違反這些原則的行為，無論來自人類還是 AI，都會被系統檢測並要求修正。
