---
title: "程式碼壞味道識別"
description: "學習識別程式碼中的問題並建立系統化的經驗傳承機制"
weight: 71
---

# 程式碼壞味道識別

「程式碼壞味道」(Code Smell) 是 Martin Fowler 在《Refactoring》一書中提出的概念，指的是程式碼中暗示深層問題的表面跡象。本章介紹如何識別這些問題，並透過 Error Patterns 系統進行經驗傳承。

## 什麼是程式碼壞味道

程式碼壞味道不是 Bug，程式仍然可以正常運作。但它們暗示著：

- **維護困難**：修改時容易出錯
- **理解成本高**：新人需要更多時間理解
- **擴展受限**：新增功能變得困難

```python
# 壞味道範例：這段程式碼能運作，但有什麼問題？
def process(data):
    result = []
    for item in data:
        if item[9:].startswith("refs/"):
            temp = item.split("/")
            if len(temp) > 2:
                if temp[2] not in ["main", "master", "develop"]:
                    result.append(temp[2])
    return result
```

上述程式碼的壞味道：
1. **魔法數字** `[9:]` - 為什麼是 9？
2. **硬編碼清單** - 分支名稱直接寫在程式碼中
3. **巢狀過深** - 三層 if 讓邏輯難以追蹤
4. **命名模糊** - `temp`、`data`、`item` 都沒有說明含義

## Error Patterns 系統

Error Patterns 是一套系統化記錄和傳承開發經驗的機制。當團隊發現重複出現的問題時，將其記錄為 Pattern，避免未來重蹈覆轍。

### 目錄結構

```
.claude/error-patterns/
├── README.md              # 系統說明
├── test/                  # 測試相關錯誤模式
├── documentation/         # 文件相關錯誤模式
├── architecture/          # 架構相關錯誤模式
└── implementation/        # 實作相關錯誤模式
```

### 命名規範

**格式**: `{CATEGORY}-{NNN}-{short-description}.md`

| 分類 | 前綴 | 說明 |
|------|------|------|
| 測試 | TEST | 測試設計、執行相關 |
| 文件 | DOC | 文件格式、規範相關 |
| 架構 | ARCH | 架構設計相關 |
| 實作 | IMP | 程式碼實作相關 |

### 實際範例

| ID | 標題 | 風險 | 說明 |
|----|------|------|------|
| ARCH-001 | 配置與程式碼混合 | 高 | 配置硬編碼在程式碼中 |
| IMP-001 | 重複程式碼散落各處 | 中 | 違反 DRY 原則 |
| IMP-002 | 魔法數字 | 低 | 難以理解的數字常數 |

## 5 Why 分析法

5 Why 是豐田生產系統發展出的根因分析方法。透過連續追問「為什麼」，找出問題的根本原因。

### 範例：魔法數字問題

```
問題：程式碼中出現難以理解的數字 line[9:]

Why 1: 為什麼會有 line[9:]？
→ 因為開發時知道 "worktree " 長度是 9，直接寫數字

Why 2: 為什麼直接寫數字？
→ 因為快速開發時忽略可讀性

Why 3: 為什麼忽略可讀性？
→ 因為沒有程式碼審查機制

Why 4: 為什麼沒有審查機制？
→ 因為專案初期沒有建立

Why 5: 為什麼初期沒有建立？
→ 【根本原因】缺乏「自文件化程式碼」的開發習慣和規範
```

### 分析技巧

1. **持續追問**：不要在表面原因停下
2. **客觀描述**：避免責怪個人
3. **可驗證**：每個「為什麼」都應該可以驗證
4. **可行動**：最終原因要能夠採取行動改善

## 常見壞味道類型

### 架構層級

| 壞味道 | 症狀 | 影響 |
|--------|------|------|
| 配置與程式碼混合 | 單一檔案超長，配置佔一半 | 修改配置需要改程式碼 |
| 循環依賴 | 模組互相引用 | 難以單獨測試 |
| 上帝類別 | 一個類別做太多事 | 修改影響範圍大 |

### 實作層級

| 壞味道 | 症狀 | 影響 |
|--------|------|------|
| 重複程式碼 | 相同邏輯在多處出現 | 修改需要改多處 |
| 魔法數字 | 難以理解的數字常數 | 維護者不知道含義 |
| 過長函式 | 函式超過 50 行 | 難以理解和測試 |
| 過深巢狀 | 超過 3 層巢狀 | 邏輯難以追蹤 |

### 測試層級

| 壞味道 | 症狀 | 影響 |
|--------|------|------|
| 過度驗證 | 測試驗證非該模組責任的東西 | 測試脆弱 |
| 測試相依 | 測試順序影響結果 | 難以獨立執行 |
| 缺乏隔離 | 測試使用真實外部資源 | 不穩定 |

## 識別壞味道的工具

### 靜態分析

```bash
# 找出超長檔案
find .claude/hooks -name "*.py" -exec wc -l {} \; | awk '$1 > 500'

# 找出重複的函式定義
grep -rh "^def " .claude/hooks/*.py | sort | uniq -c | sort -rn | head -20

# 找出可能的魔法數字
grep -rn "\[[0-9]*:\]" .claude/hooks/*.py
```

### 程式碼審查

重構前的程式碼審查清單：

- [ ] 檔案長度是否超過 500 行？
- [ ] 是否有重複的函式定義？
- [ ] 是否有硬編碼的配置？
- [ ] 是否有難以理解的數字？
- [ ] 巢狀是否超過 3 層？

## 建立 Error Pattern 的流程

當發現重複出現的問題時：

1. **識別模式**：確認問題確實是重複出現的模式
2. **分類歸檔**：選擇適當的分類目錄
3. **5 Why 分析**：找出根本原因
4. **記錄解決方案**：說明正確做法和錯誤做法
5. **更新索引**：在 README 中新增條目

### Error Pattern 文件模板

```markdown
# [Pattern ID]: [簡短標題]

## 基本資訊

- **Pattern ID**: {CATEGORY}-{NNN}
- **分類**: {分類名稱}
- **來源版本**: {發現時的版本}
- **發現日期**: YYYY-MM-DD
- **風險等級**: 高/中/低

## 問題描述

### 症狀
[描述問題的外在表現]

### 根本原因 (5 Why 分析)
1. Why 1: ...
2. Why 2: ...
3. Why 3: ...
4. Why 4: ...
5. Why 5: (根本原因)

## 解決方案

### 正確做法
[描述正確的實作方式]

### 錯誤做法 (避免)
[描述應該避免的做法]

## 相關資源

- [相關文件連結]

## 標籤

`#標籤1` `#標籤2`
```

## 實作練習

### 練習 1：識別壞味道

檢視以下程式碼，列出所有壞味道：

```python
def check(data):
    res = []
    for i in range(len(data)):
        if data[i]["type"] == "A":
            if data[i]["status"] == 1:
                if data[i]["value"] > 100:
                    res.append(data[i]["name"][5:])
    return res
```

<details>
<summary>參考答案</summary>

1. **命名模糊**：`check`、`data`、`res`、`i` 都沒有說明含義
2. **魔法數字**：`1`、`100`、`[5:]` 含義不明
3. **巢狀過深**：三層 if 巢狀
4. **字串常數**：`"type"`、`"A"`、`"status"` 應該定義為常數
5. **使用 range(len())**：應該直接迭代 `data`

</details>

### 練習 2：5 Why 分析

對於「重複程式碼散落各處」這個問題，嘗試進行 5 Why 分析。

<details>
<summary>參考答案</summary>

1. Why 1: 相同的函式在多個檔案中重複
2. Why 2: 每個 Hook 獨立開發，沒有共用模組
3. Why 3: 缺乏 Hook 系統的架構設計
4. Why 4: 快速開發時複製貼上最快
5. Why 5: 【根本原因】缺乏 DRY 原則的強制檢查機制

</details>

## 小結

- 程式碼壞味道是暗示深層問題的表面跡象
- Error Patterns 系統用於記錄和傳承開發經驗
- 5 Why 分析法幫助找出問題的根本原因
- 定期程式碼審查是識別壞味道的有效方法

## 下一步

- [配置與程式碼分離](../config-separation/) - 學習如何解決 ARCH-001
- [DRY 原則與共用程式庫](../dry-principle/) - 學習如何解決 IMP-001

---

*文件版本：v0.30.0*
*建立日期：2026-01-20*
